syntax = "proto3";

package inx;
option go_package = "github.com/iotaledger/inx/go;inx";

service INX {
  // Node
  rpc ReadNodeStatus(NoParams) returns (NodeStatus);
  rpc ListenToNodeStatus(NodeStatusRequest) returns (stream NodeStatus);
  rpc ReadNodeConfiguration(NoParams) returns (NodeConfiguration);

  // Commitments
  rpc ReadCommitment(CommitmentRequest) returns (Commitment);

  // Blocks
  rpc ListenToBlocks(NoParams) returns (stream Block);
  rpc ListenToAcceptedBlocks(NoParams) returns (stream Block);
  rpc ListenToConfirmedBlocks(NoParams) returns (stream Block);
  rpc SubmitBlock(RawBlock) returns (BlockId);
  rpc ReadBlock(BlockId) returns (RawBlock);
  rpc ReadBlockMetadata(BlockId) returns (BlockMetadata);

  // Payload
  rpc SubmitPayload(RawPayload) returns (BlockId);

  // UTXO
  rpc ReadUnspentOutputs(NoParams) returns (stream UnspentOutput);
  
  // A stream that yields updates to the ledger. A `LedgerUpdate` represents a batch to be applied to the ledger.
  // It first sends a `BEGIN`, then all the consumed outputs, then all the created outputs and finally an `END`.
  // `BEGIN` and `END` will also be sent for slots that did not mutate the ledger.
  // The counts in the batch markers can be used to sanity check that everything arrived and to pre-allocate space if needed.
  rpc ListenToLedgerUpdates(SlotRangeRequest) returns (stream LedgerUpdate);
  rpc ReadOutput(OutputId) returns (OutputResponse);

  // REST API
  rpc RegisterAPIRoute(APIRouteRequest) returns (NoParams);
  rpc UnregisterAPIRoute(APIRouteRequest) returns (NoParams);
  rpc PerformAPIRequest(APIRequest) returns (APIResponse);
}

message NoParams {}

// Node
message NodeConfiguration {
  BaseToken base_token = 1;
  repeated RawProtocolParameters protocol_parameters = 2;
}

message BaseToken {
  string name = 1;
  string ticker_symbol = 2;
  string unit = 3;
  string subunit = 4;
  uint32 decimals = 5;
  bool use_metric_prefix = 6;
}

message NodeStatus {
  bool is_healthy = 1;
  bool is_synced = 2;
  bool is_almost_synced = 3;
  uint64 last_accepted_block_slot = 4;
  uint64 last_confirmed_block_slot = 5;
  Commitment latest_commitment = 6;
  uint64 latest_finalized_slot = 7;
}

message NodeStatusRequest {
  uint32 cooldown_in_milliseconds = 1;
}

message RawProtocolParameters {
  uint32 protocol_version = 1;
  uint64 start_epoch = 2;
  bytes params = 3;
}

// Commitments
message RawCommitment {
  bytes data = 1;
}

message CommitmentId {
  bytes id = 1;
}

message CommitmentRequest {
  uint64 commitment_index = 1;
  CommitmentId commitment_id = 2;
}

message SlotRangeRequest {
  // start_slot is the initial slot to get. Use 0 to start from the current node status.
  uint64 start_slot = 1;
  // end_slot is the last slot to get (inclusive). Use 0 to keep getting new confirmed slots.
  uint64 end_slot = 2;
}

message Commitment {
  CommitmentId commitment_id = 1;
  RawCommitment commitment = 2;
}

message CommitmentAndProtocolParameters {
  Commitment commitment = 1;
  RawProtocolParameters current_protocol_parameters = 2;
}

// Blocks
message RawBlock {
  bytes data = 1;
}

message BlockId {
  bytes id = 1;
}

message Block {
  BlockId block_id = 1;
  RawBlock block = 2;
}

message BlockWithMetadata {
  BlockMetadata metadata = 1;
  RawBlock block = 2;
}

message BlockMetadata {
  BlockId block_id = 1;
  bool accepted = 2;
  bool confirmed = 3;
  bool finalized = 4;
//  enum LedgerInclusionState {
//    LEDGER_INCLUSION_STATE_NO_TRANSACTION = 0;
//    LEDGER_INCLUSION_STATE_INCLUDED = 1;
//    LEDGER_INCLUSION_STATE_CONFLICTING = 2;
//  }
//  LedgerInclusionState ledger_inclusion_state = 8;
//  enum ConflictReason {
//    CONFLICT_REASON_NONE = 0;
//    CONFLICT_REASON_INPUT_ALREADY_SPENT = 1;
//    CONFLICT_REASON_INPUT_ALREADY_SPENT_IN_THIS_MILESTONE = 2;
//    CONFLICT_REASON_INPUT_NOT_FOUND = 3;
//    CONFLICT_REASON_INPUT_OUTPUT_SUM_MISMATCH = 4;
//    CONFLICT_REASON_INVALID_SIGNATURE = 5;
//    CONFLICT_REASON_TIMELOCK_NOT_EXPIRED = 6;
//    CONFLICT_REASON_INVALID_NATIVE_TOKENS = 7;
//    CONFLICT_REASON_RETURN_AMOUNT_NOT_FULFILLED = 8;
//    CONFLICT_REASON_INVALID_INPUT_UNLOCK = 9;
//    CONFLICT_REASON_INVALID_INPUTS_COMMITMENT = 10;
//    CONFLICT_REASON_INVALID_SENDER = 11;
//    CONFLICT_REASON_INVALID_CHAIN_STATE_TRANSITION = 12;
//    CONFLICT_REASON_SEMANTIC_VALIDATION_FAILED = 255;
//  }
//  ConflictReason conflict_reason = 9;
}

// Payload
message RawPayload {
  bytes data = 1;
}


// Tips
message TipsRequest {
  uint32 count = 1;
  bool allow_semiLazy = 2;
}

message TipsResponse {
  repeated BlockId tips = 1;
}

message TipsMetricRequest {
  uint32 interval_in_milliseconds = 1;
}

message TipsMetric {
  uint32 non_lazy_pool_size = 1;
  uint32 semi_lazy_pool_size = 2;
}



// UTXO
message TransactionId {
  bytes id = 1;
}

message OutputId {
  bytes id = 1;
}

message OutputResponse {
  CommitmentId latest_commitment_id = 1;
  oneof payload {
    LedgerOutput output = 2;
    LedgerSpent spent = 3;
  }
}

message UnspentOutput {
  CommitmentId latest_commitment_id = 1;
  LedgerOutput output = 2;
}

message RawOutput {
  bytes data = 1;
}

message LedgerOutput {
  OutputId output_id = 1;
  BlockId blockId = 2;
  uint64 slot_booked = 3;
  uint64 slot_created = 4;
  RawOutput output = 5;
}

message LedgerSpent {
  LedgerOutput output = 1;
  TransactionId transaction_id_spent = 2;
  uint64 slot_spent = 3;
}

message LedgerUpdate {
  message Marker {
    uint64 slot = 1;
    enum MarkerType {
      BEGIN = 0;
      END = 1;
    }
    MarkerType marker_type = 2;
    uint32 consumed_count = 3;
    uint32 created_count = 4;
  }

  oneof op {
    Marker batch_marker = 1;
    LedgerSpent consumed = 2;
    LedgerOutput created = 3;
  }
}

// REST API
message APIRouteRequest {
  string route = 1;
  string host = 2;
  uint32 port = 3;
  string path = 4;
}

message APIRequest {
  string method = 1;
  string path = 2;
  map<string, string> headers = 3;
  bytes body = 4;
}

message APIResponse {
  uint32 code = 1;
  map<string, string>  headers = 2;
  bytes body = 3;
}
